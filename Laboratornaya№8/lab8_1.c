#include <stdio.h>
#include <stdlib.h>//библиотека для работы с выделением памяти

double opr(double **matr, int n){// создание функции для поиска определителя
    if (n == 1){
        return matr[0][0];// если размер равен 1, то определитель равен самому элементу
    }
    if (n == 2){// когда размер равен 2
        return matr[0][0] * matr[1][1] - matr[0][1] * matr[1][0];//формула для нахождения определителя
    }
    double q = 0;//переменная для хранения определителя
    for(int o = 0; o < n; o++){
        int qw = n - 1;// размер доп матрицы(без текущей строки и столбца)
        double **aff = (double **)malloc(qw * sizeof(double *));// выделение памяти дл вспомогательной матрицы для вычисления определителя
        for(int z = 0; z < qw; z++){
            aff[z] = (double *)malloc(qw * sizeof(double));//выделение памяти для каждой строки доп матрицы
        }
        for(int i = 1; i < n; i++){//заполнение вспомогательной матрицы(без текущей строки и столбца/поэтому начинаем с 1)
            int ff = 0;//индекс для столбца для доп матрицы
            for (int j = 0; j < n; j++){
                if(j != o){//пропуск столбца который исключаем
                    aff[i-1][ff] = matr[i][j];//копирование элементов в доп матрицу
                    ff++;// переход к след столбцу доп матрицы
                }
            }
        }
        double ss = (o % 2 == 0) ? 1 : -1;//если индекс столбца четный то знак положительный и наоборот
        q += ss * matr[0][o] * opr(aff,n - 1);//рекурсивное вычисление определителя(знак меняется в зависимости от столбца)
        for(int i = 0; i < (n-1); i++){
            free(aff[i]);//освобождение памяти в вспомогательной матрице
        }
        free(aff);
    }
return q;//возвращение определителя

}

void Cramer(double** matr, double* b, int n) {//функция которая решает матрицу методом крамера
    double ww = opr(matr, n);//вычисление  определителя основной матрицы
    if (ww == 0) {
        printf("определитель равен нулю(нет единственного решения)\n");
        return;//если определитель = 0 то решения нет
    }

    printf("решение:\n");
    double** ddmatr = (double**)malloc(n * sizeof(double*));//выделение памяти для матрицы которая будет изменяться при замене столбца
    for (int i = 0; i < n; i++) {
        ddmatr[i] = (double*)malloc(n * sizeof(double));//заполнение памяти для столбцов
    }

    for (int co = 0; co < n; co++) {//выччисление определителя новой матрицы 51-65
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                ddmatr[i][j] = matr[i][j]; // Копируем осн матрицу в новую
            }
        }

        for (int i = 0; i < n; i++) {
            ddmatr[i][co] = b[i]; // замена столбца на правую часть
        }

        double  tt = opr(ddmatr, n);//вычисление определителя новой матрицы которая имеет измененный столбец
        printf("x%d = %lf\n", co + 1, tt / ww); //определитель с заменой правой части
    }

    for (int i = 0; i < n; i++) {
        free(ddmatr[i]);//освобождение памяти 
    }
    free(ddmatr);
}

int main() {
    int n;
    printf("размер матрицы(n): ");
    scanf("%d", &n);
   double** matr = (double**)malloc(n * sizeof(double*));//выделение памяти 
    for (int i = 0; i < n; i++) {
        matr[i] = (double*)malloc(n * sizeof(double));//заполнение памяти для каждой строки
    }

    printf("элементы матрицы:\n");
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            printf("a[%d][%d]: ", i + 1, j + 1);//запрос для ввода элемента матрицы
            scanf("%lf", &matr[i][j]);//считывание элементов матрицы
        }
    }
   double* b = (double*)malloc(n * sizeof(double));//выделение памяти для правой части
    printf("элементы правой части:\n");
    for (int i = 0; i < n; i++) {
        printf("b[%d]: ", i + 1);//запрос для ввода элемента матрицы
        scanf("%lf", &b[i]);//ввод элемента матрицы
    }
   Cramer(matr, b, n);

    for (int i = 0; i < n; i++) {
        free(matr[i]);
    }
    free(matr);
    free(b);

    return 0;
}